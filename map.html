<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Satellite Tracking Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.curve@0.4.0/dist/leaflet.curve.min.css" />
    <style>
        body { margin: 0; padding: 0; }
        #map { height: 100vh; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.curve@0.4.0/dist/leaflet.curve.min.js"></script>
    <script>
        let satellitePaths = {};
        let map;
        const NC_LON = -79.0; // North Carolina longitude reference

        // Initialize the map immediately
        document.addEventListener("DOMContentLoaded", function () {
            initMap();
        });

        function initMap() {
            const bounds = [
                [-150, -185],
                [150, 185]
            ];
            map = L.map("map", {
                center: [35.5, -79.0],
                zoom: 3,
                maxZoom: 10,
                minZoom: 2,
                maxBounds: L.latLngBounds(bounds),
                maxBoundsViscosity: 0.8,
                crs: L.CRS.EPSG3857
            });

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                noWrap: true
            }).addTo(map);

            loadSatelliteData(map);
        }

        async function loadSatelliteData(map) {
            try {
                const response = await fetch("satellites.json");
                const data = await response.json();

                if (data.satellites && Array.isArray(data.satellites)) {
                    data.satellites.forEach((satellite) => {
                        addSatellite(map, satellite);
                    });
                }
            } catch (error) {
                console.error("Error loading satellite data:", error);
            }
        }

        function addSatellite(map, satellite) {
            const currentPos = satellite.current_position;
            const futurePos = satellite.future_passes;

            // Add marker for current position
            const marker = L.marker([currentPos.lat, currentPos.lon])
                .addTo(map)
                .bindPopup(`
                    <h3>${satellite.name}</h3>
                    <p><strong>Time:</strong> ${currentPos.timestamp}</p>
                    <p><strong>Altitude:</strong> ${Math.round(currentPos.altitude)} km</p>
                    <p><strong>Latitude:</strong> ${currentPos.lat.toFixed(4)}°</p>
                    <p><strong>Longitude:</strong> ${currentPos.lon.toFixed(4)}°</p>
                    <p><strong>Minutes from NC:</strong> ${futurePos[0]?.minutes_from_now || "N/A"}</p>
                    <p><a href="${satellite.details_url}" target="_blank">Learn More</a></p>
                `);

            let pathSegments = [];
            let lastPoint = [currentPos.lat, currentPos.lon];

            // Create path segments with dateline crossing adjustment
            satellite.future_passes.forEach((pass) => {
                const nextPoint = [pass.lat, pass.lon];
                const segments = createWrappedPath(lastPoint, nextPoint);  // Correct path function for east-to-west
                pathSegments.push(...segments);
                lastPoint = nextPoint;
            });

            // Store and draw the Bézier curves
            satellitePaths[satellite.name] = pathSegments.map(
                (segment) =>
                    L.curve(segment, {
                        color: "#2196F3",
                        weight: 2.5,
                        opacity: 0.7,
                        smoothFactor: 1.5,
                        lineJoin: "round"
                    })
            );

            // Add event listener to the marker
            marker.on("click", function () {
                showPath(satellite.name);
            });
        }

        function showPath(satelliteName) {
            // Remove all currently shown paths
            Object.keys(satellitePaths).forEach((name) => {
                satellitePaths[name].forEach((path) => path.remove());
            });

            // Show the selected satellite's path
            satellitePaths[satelliteName].forEach((path) => {
                path.addTo(map);
            });
        }

        function createWrappedPath(start, end) {
            let segments = [];
            const startLon = start[1];
            const endLon = end[1];

            // Since satellites move east-to-west, we adjust the path when crossing the dateline
            if (startLon < endLon) {
                const midLat = (start[0] + end[0]) / 2;   // Midpoint latitude for smoother transition
                const midLon = 180; // Crossing the dateline at 180°

                // First segment from start to the dateline
                segments.push([ 
                    [start[0], startLon],
                    [midLat, midLon]
                ]);

                // Second segment after crossing the dateline to the end point
                segments.push([
                    [midLat, -180], // Wrap to the opposite side of the dateline
                    [end[0], endLon]
                ]);
            } else {
                // If the satellite doesn't cross the dateline, we just draw the normal path
                segments.push([
                    [start[0], startLon],
                    [end[0], endLon]
                ]);
            }

            return segments; // Returning path segments
        }
    </script>
</body>
</html>
