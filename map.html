<!DOCTYPE html>
<html lang="en">
<head>
    <title>Satellite Tracking Map</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map {
            width: 100%;
            height: 400px;
        }
        .controls {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            display: none;  /* Hidden by default */
        }
    </style>
</head>
<body>
    <header>
        <h1>Satellite Tracker</h1>
        <p>Track satellites and the straight-line predicted path to North Carolina</p>
    </header>

    <div class="controls" id="controls">
        <!-- Controls can be used for additional features in the future -->
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        let satellitePaths = {};
        let map;
        const NC_LON = -79.0; // North Carolina longitude reference

        // Initialize the map immediately
        document.addEventListener("DOMContentLoaded", function() {
            initMap();
        });

        function initMap() {
            const bounds = [
                [-150, -185],
                [150, 185]
            ];
            map = L.map('map', {
                center: [35.5, -79.0],
                zoom: 3,
                maxZoom: 10,
                minZoom: 2,
                maxBounds: L.latLngBounds(bounds),
                maxBoundsViscosity: 0.8,
                crs: L.CRS.EPSG3857
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                noWrap: true
            }).addTo(map);

            loadSatelliteData(map);
        }

        function createWrappedPath(start, end) {
            let segments = [];
            const startLon = start[1];
            const endLon = end[1];
            let diffLon = endLon - startLon;
            const latDiff = end[0] - start[0];
            
            // Adjust the path for satellites east of NC to go around the world westward
            if (startLon > NC_LON && diffLon > 0) {
                // Go westward around the world
                diffLon = -(360 - diffLon);
            }
            
            // If crossing the international date line
            if (Math.abs(diffLon) > 180) {
                // Calculate how far along the path we need to split
                const ratio = (180 - Math.abs(startLon)) / Math.abs(diffLon);
                const splitLat = start[0] + (latDiff * ratio);
                
                if (diffLon > 0) {
                    // Going eastward across dateline
                    segments.push([
                        [start[0], startLon],
                        [splitLat, -180]
                    ]);
                    segments.push([
                        [splitLat, 180],
                        [end[0], endLon]
                    ]);
                } else {
                    // Going westward across dateline
                    segments.push([
                        [start[0], startLon],
                        [splitLat, 180]
                    ]);
                    segments.push([
                        [splitLat, -180],
                        [end[0], endLon]
                    ]);
                }
            } else {
                // No date line crossing, single segment
                segments.push([
                    [start[0], startLon],
                    [end[0], endLon]
                ]);
            }
            
            return segments;
        }

        async function loadSatelliteData(map) {
            try {
                const response = await fetch('satellites.json');
                const data = await response.json();

                if (data.satellites && Array.isArray(data.satellites)) {
                    data.satellites.forEach(satellite => {
                        addSatellite(map, satellite);
                    });
                }
            } catch (error) {
                console.error('Error loading satellite data:', error);
            }
        }

        function addSatellite(map, satellite) {
            const currentPos = satellite.current_position;
            const futurePos = satellite.future_passes;
            
            // Add marker for current position
            const marker = L.marker([currentPos.lat, currentPos.lon])
                .addTo(map)
                .bindPopup(` 
                    <h3>${satellite.name}</h3>
                    <p><strong>Time:</strong> ${currentPos.timestamp}</p>
                    <p><strong>Altitude:</strong> ${Math.round(currentPos.altitude)} km</p>
                    <p><strong>Latitude:</strong> ${currentPos.lat.toFixed(4)}°</p>
                    <p><strong>Longitude:</strong> ${currentPos.lon.toFixed(4)}°</p>
                    <p><strong>Minutes from NC:</strong> ${futurePos[0]?.minutes_from_now || 'N/A'}</p>
                    <p><a href="${satellite.details_url}" target="_blank">Learn More</a></p>
                `);

            let pathSegments = [];
            let lastPoint = [currentPos.lat, currentPos.lon];

            // Create path segments for each point in future_passes
            satellite.future_passes.forEach(pass => {
                const nextPoint = [pass.lat, pass.lon];
                const segments = createWrappedPath(lastPoint, nextPoint);
                pathSegments.push(...segments);
                lastPoint = nextPoint;
            });

            // Store the paths with smoother styling
            satellitePaths[satellite.name] = pathSegments.map(segment => 
                L.polyline(segment, {
                    color: '#2196F3',
                    weight: 2.5,
                    opacity: 0.7,
                    smoothFactor: 1.5,
                    lineJoin: 'round'
                })
            );

            // Add event listener to the marker
            marker.on('click', function() {
                showPath(satellite.name);
            });
        }

        function showPath(satelliteName) {
            // Remove all currently shown paths
            Object.keys(satellitePaths).forEach(name => {
                satellitePaths[name].forEach(path => path.remove());
            });

            // Show the selected satellite's path
            satellitePaths[satelliteName].forEach(path => {
                path.addTo(map);
            });
        }
    </script>
</body>
</html>
